//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace Bakalarka
{
	public class Math2f
	{
		public static double EULER =2.71828;

		public static int Factorial(int n)
		{
			int result = 1;
			for (int i = 1; i <= n ; i++) result *= i;
			return result;
		}

		public static int BinomialCoefficient(int n , int k)
		{
			if (n < k) return 0; 
			return Factorial(n) / ( Factorial(k)* Factorial(n - k) );
		}

		//http://math.stackexchange.com/questions/340124/binomial-coefficients-1-2-k
		public static float HalfBinomialCoefficient( int n )
		{
			if (n == 0) return 1.0f;
			float n1 = Mathf.Pow(-1, n - 1) / ( Mathf.Pow(2, 2*n - 1) * n );
			float n2 = BinomialCoefficient( 2*n - 2 , n -1 );
			return n1*n2;
		}

		public const float MIN_TO_HOUR = 0.0166666667f;
		public const float SEC_TO_HOUR = 0.000277777778f;
	}

	public class Ellipse
	{
		public const float SCALE_PARAM = 100000;

		public Vector3 U;
		public Vector3 V;
		public float e; //eccentricity
		
		public float semi_major;
		public float semi_minor;

		private float apsisDistance;

		public Vector3 getF1( )
		{
			float F = Mathf.Sqrt( semi_major*semi_major  - semi_minor*semi_minor );
			Vector3 F1 = -F*U;
			return F1;
		}
		
		public Vector3 getF2( )
		{
			float F = Mathf.Sqrt( semi_major*semi_major  - semi_minor*semi_minor );
			Vector3 F1 = F*U;
			return F1;
		}

		
		public Ellipse( float semi_minor , float semi_major )
		{
			this.U = new Vector3(1,0,0);
			this.V = new Vector3(0,1,0);
			this.semi_major = semi_major;
			this.semi_minor = semi_minor;
			this.e = (float) Math.Sqrt( semi_major*semi_major - semi_minor*semi_minor)/semi_major;
		}

		public Ellipse(Vector3 U, Vector3 V, float apsisDistance , float e)
		{
			this.U = U.normalized;
			this.V = V.normalized;
			this.e = e;
			this.semi_major = apsisDistance / ( 1 + e);
			this.semi_minor  = semi_major*Mathf.Sqrt( 1 - e*e );
			this.apsisDistance = apsisDistance;
		}

		public float getApsisDistance(){
			return apsisDistance;
		}

		public Vector3 getPosition(float angle ){
			return getPosition(angle, 1.0f, 0 );
		}
		
		public Vector3 getPosition(float angle, float scale , float rotation )
		{
			angle = Mathf.Deg2Rad * angle;
			Vector3 result = new Vector3();
			result.x =  scale*semi_major * Mathf.Cos(angle)*U.x + scale*semi_minor * Mathf.Sin(angle)*V.x;
			result.y =  scale*semi_major * Mathf.Cos(angle)*U.y + scale*semi_minor * Mathf.Sin(angle)*V.y;
			result.z =  scale*semi_major * Mathf.Cos(angle)*U.z + scale*semi_minor * Mathf.Sin(angle)*V.z;

			result = Quaternion.AngleAxis (rotation, new Vector3(0,1,0)) * result;
			return result;
		}
		
		public Vector3 getVelocityDirection( float angle )
		{
			angle = Mathf.Deg2Rad * angle;
			Vector3 v = new Vector3();
			v.x = -semi_major * Mathf.Sin(angle)*U.x + semi_minor * Mathf.Cos(angle)*V.x;
			v.y = -semi_major * Mathf.Sin(angle)*U.y + semi_minor * Mathf.Cos(angle)*V.y;
			v.z = -semi_major * Mathf.Sin(angle)*U.z + semi_minor * Mathf.Cos(angle)*V.z;
			v.Normalize();
			return v;
		}
		
		public float getAreaVelocity(float gravitParam)
		{
			Vector3 aphelion = getPosition(0) - getF1();
			float minimumSpeed = getMinimumSpeed(gravitParam);
			float area = ( aphelion.magnitude * minimumSpeed ) / 2;
			return area;
		}

		public float getAngularVelocity(float angle , float area)
		{ 
			Vector3 v = getVelocity(angle, area);
			Vector3 r = getPosition(angle);
			float theta = Vector3.Angle(r, v)*Mathf.Deg2Rad;
			float w = (v.magnitude * Mathf.Sin(theta) )  / r.magnitude;
			return w;
		}

		public Vector3 getVelocity(float angle  , float area)
		{
			Vector3 r = getPosition(angle) - getF1();
			float vAnsSinTheta = (2*area) / r.magnitude;
			Vector3 velocityDir = getVelocityDirection(angle);
			float theta = Vector3.Angle(r, velocityDir)*Mathf.Deg2Rad;
			float velocity =vAnsSinTheta / Mathf.Sin(theta);
			return velocityDir*velocity;
		}

		public float getMinimumSpeed(float gravitParameter)
		{
			float velocity =  Mathf.Sqrt( ((1 - e)*gravitParameter) / ( (1+e)*semi_major ) ); 
			return velocity;
			//float angularVelocity = velocity / semi_major ;
			//return angularVelocity;
		}


		public float getArea() {return Mathf.PI*semi_major*semi_minor;}
		
		public void drawAroundPoint( Vector3 point, float scale , float rotation )
		{
			for (int i = 0 ; i < 360 ; i++ )
			{
				Vector3 p1 = point + getPosition(i , scale,  rotation  );
				Vector3 p2 = point + getPosition( (i + 1) %  360 , scale, rotation );
				Debug.DrawLine(p1 , p2, Color.blue);
			}
		}

		public void drawAroundPoint( Vector3 point, float scale , float rotation , LineRenderer renderer , Transform t, bool isSelected)
		{
			if (renderer != null)
			{		
				renderer.material= new Material(Shader.Find("Particles/Additive"));		
				renderer.SetVertexCount( 360+1 );
				if (isSelected){
					renderer.SetColors(new Color(1,0.3f,0.3f,0.3f), new Color(1,0.3f,0.3f,0.3f));
					renderer.SetWidth(12,12);
				}else{
					renderer.SetColors(new Color(1,1,1,0.3f), new Color(1,1,1,0.3f));
					renderer.SetWidth(7,7);
				}
				for (int i = 0 ; i <= 360 ; i++ )
				{
					Vector3 p1 = point + getPosition((float)i , 1.0f,  rotation  );
					//Vector3 p2 = point + getPosition( (i + 1) %  360 , scale, rotation );
					renderer.SetPosition(i, t.parent.transform.TransformPoint(  p1)  );			//Debug.DrawLine(p1 , p2, Color.blue);
				}
			}
		}


		public float getAverageOrbitalSpeed( float gravitParam ){return Mathf.Sqrt(gravitParam / semi_major);}

		public float getPerimeter()
		{
			float a = semi_major;
			float b = semi_minor;
			float result = Mathf.PI *( 3.0f*( a + b) - Mathf.Sqrt( (3.0f*a + b )*( a + 3.0f*b) ) );
			return result;
		}


		public float getPeriod(float gravitParam)
		{
			float v = getAverageOrbitalSpeed(gravitParam);
			float s = getPerimeter();
			float period = SCALE_PARAM*(s / (v*3600 ));
			return period;
		}

		public float getGravitationParameter( float period )
		{
			period = period / SCALE_PARAM;
			float s = getPerimeter();
			float v = s / (period*3600);
			float result = semi_major * v*v;
			return result;
		}
	}
}


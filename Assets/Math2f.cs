//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace Bakalarka
{
	public class Math2f
	{
		public static int Factorial(int n)
		{
			int result = 1;
			for (int i = 1; i <= n ; i++) result *= i;
			return result;
		}

		public static int BinomialCoefficient(int n , int k)
		{
			if (n < k) return 0; 
			return Factorial(n) / ( Factorial(k)* Factorial(n - k) );
		}

		//http://math.stackexchange.com/questions/340124/binomial-coefficients-1-2-k
		public static float HalfBinomialCoefficient( int n )
		{
			if (n == 0) return 1.0f;
			float n1 = Mathf.Pow(-1, n - 1) / ( Mathf.Pow(2, 2*n - 1) * n );
			float n2 = BinomialCoefficient( 2*n - 2 , n -1 );
			return n1*n2;
		}

		public const float MIN_TO_HOUR = 0.0166666667f;
		public const float SEC_TO_HOUR = 0.000277777778f;
	}

	public class Ellipse
	{
		public const float SCALE_PARAM = 100000;

		public Vector3 U;
		public Vector3 V;
		public float e; //eccentricity
		
		public float semi_major;
		public float semi_minor;
		
		public Vector3 getF1( )
		{
			float F = Mathf.Sqrt( semi_major*semi_major  - semi_minor*semi_minor );
			Vector3 F1 = -F*U;
			return F1;
		}
		
		public Vector3 getF2( )
		{
			float F = Mathf.Sqrt( semi_major*semi_major  - semi_minor*semi_minor );
			Vector3 F1 = F*U;
			return F1;
		}

		
		public Ellipse( float semi_minor , float semi_major )
		{
			this.U = new Vector3(1,0,0);
			this.V = new Vector3(0,1,0);
			this.semi_major = semi_major;
			this.semi_minor = semi_minor;
			this.e = (float) Math.Sqrt( semi_major*semi_major - semi_minor*semi_minor)/semi_major;
		}

		public Ellipse(Vector3 U, Vector3 V, float apsisDistance , float e)
		{
			this.U = U.normalized;
			this.V = V.normalized;
			this.e = e;
			this.semi_major = apsisDistance / ( 1 + e);
			this.semi_minor  = semi_major*Mathf.Sqrt( 1 - e*e );
		}
		
		public Vector3 getPosition(float angle)
		{
			angle = Mathf.Deg2Rad * angle;
			Vector3 result = new Vector3();
			result.x =  semi_major * Mathf.Cos(angle)*U.x + semi_minor * Mathf.Sin(angle)*V.x;
			result.y =  semi_major * Mathf.Cos(angle)*U.y + semi_minor * Mathf.Sin(angle)*V.y;
			result.z =  semi_major * Mathf.Cos(angle)*U.z + semi_minor * Mathf.Sin(angle)*V.z;
			return result;
		}
		
		public Vector3 getVelocityDirection( float angle )
		{
			Vector3 v = new Vector3();
			v.x = -semi_major * Mathf.Sin(angle)*U.x + semi_minor * Mathf.Cos(angle)*V.x;
			v.y = -semi_major * Mathf.Sin(angle)*U.y + semi_minor * Mathf.Cos(angle)*V.y;
			v.z = -semi_major * Mathf.Sin(angle)*U.z + semi_minor * Mathf.Cos(angle)*V.z;
			v.Normalize();
			return v;
		}
		
		public float getAreaVelocity(float angle,  float angularSpeed )
		{
			Vector3 r = getPosition( angle ) - getF1();
			float mr = r.magnitude;
			float area = (mr*mr*Mathf.Deg2Rad*angularSpeed)/2;
			return area;
		}

		public float getAngularSpeed(float angle,  float area )
		{
			Vector3 r = getPosition( angle ) - getF1();
			float mr = r.magnitude;
			float angularSpeed = (2*area) / (mr*mr);
			return Mathf.Rad2Deg*angularSpeed;
		}
		
		public float getMinimumSpeed(float gravitParameter)
		{
			float velocity =  Mathf.Sqrt( ((1 - e)*gravitParameter) / ( (1+e)*semi_major ) ); 
			float angularVelocity = velocity / semi_major ;
			return angularVelocity;
		}
		
		public float toVelocity(float angularVelocity){ return angularVelocity * semi_major; }
		
		public float getArea() {return Mathf.PI*semi_major*semi_minor;}
		
		public void drawAroundPoint( Vector3 point )
		{
			for (int i = 0 ; i < 360 ; i++ )
			{
				Vector3 p1 = point + getPosition(i);
				Vector3 p2 = point + getPosition( (i + 1) %  360);
				Debug.DrawLine(p1 , p2, Color.blue);
			}
		}
		
		public float getAverageOrbitalSpeed( float gravitParam ){return Mathf.Sqrt(gravitParam / semi_major);}

		public float getPerimeter(){ return getPerimeter(10);}

		/*public float getPerimeter( int accuracy )
		{
			float h = Mathf.Pow( semi_major - semi_minor , 2 ) /  Mathf.Pow( semi_major + semi_minor , 2 );
			double accuratePart = 0;
			for ( int i = 0 ; i < accuracy; i++)
			{
				double secondPart = Mathf.Pow(h,i);
				double firstPart = Mathf.Pow( Math2f.HalfBinomialCoefficient(i),2);
				accuratePart += firstPart*secondPart;	 
			}
			return Mathf.PI * ( semi_major + semi_minor) *accuratePart;
		}*/

		public float getPerimeter( int accuracy )
		{
			float a = semi_major;
			float b = semi_minor;
			float result = Mathf.PI *( 3.0f*( a + b) - Mathf.Sqrt( (3.0f*a + b )*( a + 3.0f*b) ) );
			return result;
		}


		public float getPeriod(float gravitParam)
		{
			float v = getAverageOrbitalSpeed(gravitParam);
			float s = getPerimeter();
			float period = SCALE_PARAM*(s / (v*3600 ));
			return period;
		}

		public float getGravitationParameter( float period )
		{
			period = period / SCALE_PARAM;
			float s = getPerimeter();
			float v = s / (period*3600);
			float result = semi_major * v*v;
			return result;
		}
	}
}

